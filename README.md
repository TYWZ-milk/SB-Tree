# SB-Tree
Simple Blending Tree

## 概述
采用`层次化`的方式来实现过渡树木，省去拓扑结构中复杂冗余的步骤。同时采用`重用`的方法来实现轻量级建模。

## 开发环境
[threejs](https://threejs.org/)

## 初步效果
![](https://github.com/TYWZ-milk/SB-Tree/raw/master/images/result1.png)
![](https://github.com/TYWZ-milk/SB-Tree/raw/master/images/result2.png)
>以上效果为ALO6a与Blue Spruce两棵树的过渡树木。AL06a与Blue Spruce均为3层树木，图中每棵树均有大约500棵枝干。左右分别为两棵原始树木，中间为过渡树木。

## 算法实现
* 输入是：三维树木网格数据， T1 and T2。

* 提取树木骨架数据，树木以层次信息存储，每个骨架点存储树木的骨架坐标信息+半径。
* 建立树木枝干之间的对应关系。必要时需增加长度为零的枝干，可以先找两棵各层次枝干数目完全一样的树木，这样就免去增加零枝干。
* 将树木表示成父亲-孩子结构（数据结构中的那个树结构），然后将此时树结构的每条边用n个点表示，按照顺序将所有边的点写进一个高维向量，整颗树木可以用这个高维向量表示。
* T1与T2的middle tree是: midTree(T1,T2) =( vector(T1)+vector(T2) ) / 2.其中vector(T1)是树木T1经过step4后的向量表示， vector(T2)是树木T2经过step4后的向量表示
* midTree(T1, T2) 此时是一个高维向量，按照4的逆过程将其变为一棵三维空间中的树。
* 计算T1与midTree(T1, T2) 的middle tree, 以及midTree(T1, T2) 与T2的middle tree， 此时可以得到T1与T2之间的3棵过渡树木。
* 重复上一步骤，可以得到更多的过渡树木。

## 待解决问题
>`重用`问题尚未解决。
>>由于浏览器渲染压力过大，以AL06a与Blue Spruce为原始树木生成过渡树木时，最多可加载9棵树木，超过9棵将造成浏览器崩溃。
>>解决办法是重用原始树木的枝干，将生成的新枝干的节点信息与原始树木的枝干做对比，挑选出相似度最高的原始树木的枝干，将该枝干尺寸修改后添加到场景中。
>>目前缺少相似度匹配模块。

>界面待优化
>>最终的程序应当实现多棵树木之间可以生成过渡树木，可以向浏览器中添加树木模型。
>>目前只有两棵原始树木，且不能添加新树木到浏览器当中。

>性能提高
>>初始页面加载过慢，性能有待提高。
